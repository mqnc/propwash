<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/x-icon" href="media/favicon.ico">
    <title>PropWash</title>
    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@v0.182.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.182.0/examples/jsm/"
      }
    }
    </script>
</head>

<body style="margin:0; overflow:hidden; background-color: #123456;">

    <div id="battery" style="
        height:33.333vh;
        width:calc(33.333vh * 0.3);
        position:absolute;
        top:50%;
        left:50%;
        transform:translate(-50%,-50%);
        border:4px solid white;
        border-radius:20px;
        box-sizing:border-box;
        padding:10px;
        display:flex;
        flex-direction:column;
        justify-content:flex-end;
        pointer-events: none;
    ">
        <div id="progress" style="
            height:0%;
            width:100%;
            background:lime;
            border-radius:4px;
            position:relative;
            overflow:hidden;
        "></div>
        <span id="clickLabel" style="
            position:absolute;
            top:50%;
            left:50%;
            transform:translate(-50%,-50%) rotate(-90deg);
            white-space:nowrap;
            font-size:5vh;
            font-family:monospace;
            font-weight:bold;
            color:#123456;
        ">Click!</span>
    </div>

    <script type="module">
        //import RAPIER from 'https://cdn.skypack.dev/@dimforge/rapier3d-compat';
        import RAPIER from 'https://cdn.skypack.dev/pin/@dimforge/rapier3d-compat@v0.19.3-Hmo5REaX4aU99UROofMk/mode=imports,min/optimized/@dimforge/rapier3d-compat.js'
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { HDRLoader } from 'three/addons/loaders/HDRLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { controlInputs } from './controls.js'

        const params = new URLSearchParams(window.location.search);
        const debug = params.get('debug') === 'true';
        const env = params.get('env') ?? 'pretoria_gardens_1k';
        const map = params.get('map') ?? 'playground_2b';

        window.THREE = THREE;

        async function main() {

            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            const canvas = renderer.domElement;
            document.body.appendChild(canvas);

            // Loaders
            const hdrLoader = new HDRLoader();
            const gltfLoader = new GLTFLoader();
            const audioLoader = new THREE.AudioLoader();

            function waitForClick(target = canvas) {
                return new Promise(resolve => {
                    target.addEventListener('click', () => {
                        canvas.requestPointerLock()
                        document.getElementById('clickLabel').style.display = 'none'
                        resolve();
                    }, { once: true });
                });
            }

            // Load Resources
            let progressList = {}
            let loaderCounter = 0
            function progressCallbackFactory() {
                const loaderId = loaderCounter++
                return (e) => {
                    progressList[loaderId] = [e.loaded, e.total]
                    if (Object.keys(progressList).length === loaderCounter) {
                        let loaded = 0, total = 0
                        for (const progress of Object.values(progressList)) {
                            // loaded can be bigger than total... :/
                            loaded += Math.min(progress[0], progress[1])
                            total += progress[1]
                        }
                        document.getElementById('progress').style.height = `${100 * loaded / total}%`
                    }
                }
            }

            let [
                rapier,
                envMap,
                terrainModel,
                droneModel,
                propWav,
                musicWav,
                clicked
            ] = await Promise.all([
                RAPIER.init(),
                hdrLoader.loadAsync(`assets/envs/${env}.hdr`, progressCallbackFactory()),
                gltfLoader.loadAsync(`assets/maps/${map}.glb`, progressCallbackFactory()),
                gltfLoader.loadAsync('assets/drones/racing_drone_lite_graphics_version.glb', progressCallbackFactory()),
                audioLoader.loadAsync('assets/sound/prop_loop.mp3', progressCallbackFactory()),
                audioLoader.loadAsync('assets/music/fsm-team-escp-magenta-metropolis.mp3', progressCallbackFactory()),
                waitForClick()
            ])

            document.getElementById('battery').style.display = 'none'

            canvas.addEventListener("click", e => {
                if (e.button !== 0) return;

                if (document.pointerLockElement === null) {
                    canvas.requestPointerLock();
                } else {
                    document.exitPointerLock();
                }
            });

            // Scene
            const scene = new THREE.Scene();
            window.scene = scene
            scene.background = new THREE.Color(0x87ceeb);

            // Lighting
            envMap.mapping = THREE.EquirectangularReflectionMapping;
            scene.environment = envMap;
            scene.background = envMap;

            // Rapier World
            const world = new RAPIER.World({ x: 0.0, y: -9.81, z: 0.0 });
            const groundBody = world.createRigidBody(new RAPIER.RigidBodyDesc(RAPIER.RigidBodyType.Fixed).setTranslation(0, -1, 0));
            world.createCollider(RAPIER.ColliderDesc.cuboid(50, 0.1, 50), groundBody);

            // Drone
            const droneSize = { x: 0.3, y: 0.06, z: 0.3 };
            const droneBody = world.createRigidBody(
                new RAPIER.RigidBodyDesc(RAPIER.RigidBodyType.Dynamic)
                    .setTranslation(0, 5, 0)
            );
            droneBody.setLinearDamping(2.0);
            droneBody.setAngularDamping(3.0);

            const droneCollider = world.createCollider(
                RAPIER.ColliderDesc.cuboid(droneSize.x / 2, droneSize.y / 2, droneSize.z / 2),
                droneBody
            );

            let droneNode = new THREE.Object3D()
            scene.add(droneNode)

            let droneMesh = droneModel.scene
            droneMesh.scale.set(0.03, 0.03, 0.03)
            droneMesh.position.y = -0.02
            droneNode.add(droneMesh);

            if (debug) {
                const droneBox = new THREE.Mesh(
                    new THREE.BoxGeometry(droneSize.x, droneSize.y, droneSize.z),
                    new THREE.MeshStandardMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 })
                );
                droneNode.add(droneBox);
            }

            const droneMixer = new THREE.AnimationMixer(droneMesh);
            droneModel.animations.forEach((clip) => { droneMixer.clipAction(clip).play(); });

            // Camera
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            scene.add(camera)

            // orbit controls do not work with a parent object, so we need to create a global dummy camera and copy its pose to the drone camera
            const camDummy = new THREE.PerspectiveCamera();
            scene.add(camDummy);
            camDummy.position.set(0, -0.4, 1)
            camDummy.lookAt(0, 0, 0)
            const orbit = new OrbitControls(camDummy, renderer.domElement);
            orbit.update()
            orbit.screenSpacePanning = true;
            orbit.minDistance = 0.3;
            orbit.maxDistance = 3;
            orbit.mouseButtons = {
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.ROTATE
            }
            // target pose for camera which it will follow with some PT1 smoothing
            const camTarget = new THREE.Object3D()
            droneNode.add(camTarget)

            // Debug
            const debugGeometry = new THREE.BufferGeometry();
            const debugMaterial = new THREE.LineBasicMaterial({ vertexColors: true });
            const debugLines = new THREE.LineSegments(debugGeometry, debugMaterial);
            debugLines.renderOrder = 999;
            scene.add(debugLines);

            // Terrain
            let terrain = terrainModel.scene
            scene.add(terrain);

            terrain.updateWorldMatrix(true, true);
            terrain.traverse((child) => {
                // extract geometry for physics

                if (!child.isMesh) return;

                const geom = child.geometry;
                const posAttr = geom.attributes.position;
                const indexAttr = geom.index;

                const worldMatrix = child.matrixWorld;
                const v = new THREE.Vector3();

                const worldPositions = new Float32Array(posAttr.count * 3);

                for (let i = 0; i < posAttr.count; i++) {
                    v.fromBufferAttribute(posAttr, i);
                    v.applyMatrix4(worldMatrix);

                    worldPositions[i * 3 + 0] = v.x;
                    worldPositions[i * 3 + 1] = v.y;
                    worldPositions[i * 3 + 2] = v.z;
                }

                const indices = indexAttr ? indexAttr.array : undefined;

                const trimeshDesc = RAPIER.ColliderDesc.trimesh(worldPositions, indices);
                world.createCollider(trimeshDesc);
            });
            if (debug) {
                updateDebugRender()
            }

            // Sound
            const listener = new THREE.AudioListener();
            camera.add(listener);
            const propSounds = []
            const baseFrequency = 900;
            for (let i = 0; i < 4; i++) {
                const sound = new THREE.PositionalAudio(listener);
                sound.setBuffer(propWav);
                sound.setLoop(true);
                // work around for this: https://discourse.threejs.org/t/start-audio-with-correct-volume-instead-of-quickly-ramping-down-from-100/89793
                sound.gain.gain.value = 0.00;
                setTimeout(() => sound.setVolume(0.03), 50);
                sound.play();
                droneNode.add(sound);
                propSounds.push(sound)
            }
            function setFrequency(iMotor, frequency) {
                const factor = frequency / baseFrequency;
                const octaves = Math.log2(factor);
                const cents = octaves * 1200
                propSounds[iMotor].setDetune(cents)
            }
            const music = new THREE.Audio(listener);
            music.setBuffer(musicWav);
            music.setLoop(true);
            music.setVolume(0.15);
            music.play();

            // Controls
            function handleControls() {

                const { throttleInput, yawInput, pitchInput, rollInput } = controlInputs()

                let t = performance.now() / 1000
                let frequencies = [
                    480 + 3 * Math.sin(t),
                    485 + 2 * Math.sin(t * 0.91245142),
                    490 + 5 * Math.sin(t * 0.85234134),
                    495 + 4 * Math.sin(t * 0.73514635)
                ]

                const throttle = Math.pow(throttleInput, 2);

                frequencies[0] += + pitchInput * 20 + yawInput * 20 + rollInput * 20
                frequencies[1] += + pitchInput * 20 - yawInput * 20 - rollInput * 20
                frequencies[2] += - pitchInput * 20 + yawInput * 20 - rollInput * 20
                frequencies[3] += - pitchInput * 20 - yawInput * 20 + rollInput * 20

                for (let i = 0; i < 4; i++) {
                    frequencies[i] += throttle * 300
                    setFrequency(i, frequencies[i])
                }

                const localForce = new RAPIER.Vector3(0, throttle * 0.2, 0); // up in local drone space
                const localTorque = new RAPIER.Vector3(
                    pitchInput * 0.0005,  // X rotation
                    yawInput * 0.0005,    // Y rotation
                    rollInput * 0.0005    // Z rotation
                );

                const rotation = droneBody.rotation();
                const q = new THREE.Quaternion(rotation.x, rotation.y, rotation.z, rotation.w);

                const forceVec = new THREE.Vector3(localForce.x, localForce.y, localForce.z).applyQuaternion(q);
                const torqueVec = new THREE.Vector3(localTorque.x, localTorque.y, localTorque.z).applyQuaternion(q);

                droneBody.resetForces(true);
                droneBody.resetTorques(true);

                droneBody.addForce(new RAPIER.Vector3(forceVec.x, forceVec.y, forceVec.z), true);
                droneBody.addTorque(new RAPIER.Vector3(torqueVec.x, torqueVec.y, torqueVec.z), true);

            }

            function updateDebugRender() {
                const { vertices, colors } = world.debugRender();

                const positions = new Float32Array(vertices);
                const colorArray = new Float32Array(colors);

                debugGeometry.setAttribute(
                    'position',
                    new THREE.BufferAttribute(positions, 3)
                );

                debugGeometry.setAttribute(
                    'color',
                    new THREE.BufferAttribute(colorArray, 4)
                );

                debugGeometry.computeBoundingSphere();
            }

            const raycaster = new THREE.Raycaster();

            function updateCamera() {
                const fraction = 0.5
                let viewDir = camDummy.position.clone()
                droneNode.localToWorld(viewDir)
                viewDir.sub(droneNode.position)
                let far = viewDir.length()
                viewDir.normalize()
                raycaster.set(droneNode.position, viewDir)
                raycaster.far = far / fraction
                const intersects = raycaster.intersectObject(terrain, true)
                if (intersects.length > 0) {
                    const intersect = intersects[0]
                    camTarget.position.copy(intersect.point)
                    droneNode.worldToLocal(camTarget.position)
                    camTarget.position.multiplyScalar(fraction)
                }
                else {
                    camTarget.position.copy(camDummy.position);
                }
                camTarget.quaternion.copy(camDummy.quaternion);

                camera.position.lerp(camTarget.getWorldPosition(new THREE.Vector3()), 0.45)
                camera.quaternion.slerp(camTarget.getWorldQuaternion(new THREE.Quaternion()), 0.3)
            }

            // Animate Loop
            const dt = 1 / 60;
            function animate() {
                requestAnimationFrame(animate);

                // physics step
                world.step();

                // update drone mesh
                const pos = droneBody.translation();
                const rot = droneBody.rotation();
                droneNode.position.set(pos.x, pos.y, pos.z);
                droneNode.quaternion.set(rot.x, rot.y, rot.z, rot.w);

                handleControls();
                updateCamera();

                droneMixer.setTime(Math.random() * 1000)

                renderer.render(scene, camera);
            }

            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        main()

    </script>
</body>

</html>